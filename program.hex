00500113  // addi x2, x0, 5       ; x2 = 0 + 5 → x2 = 5
00C00193  // addi x3, x0, 12      ; x3 = 0 + 12 → x3 = 12
FF718393  // addi x7, x3, -9      ; x7 = x3 - 9 → x7 = 3
0023E233  // or x4, x7, x2        ; x4 = x7 | x2
0041F2B3  // and x5, x3, x4       ; x5 = x3 & x4
004282B3  // add x5, x5, x4       ; x5 = x5 + x4
02728863  // beq x5, x7, 12       ; if x5 == x7 → PC += 12
0041A233  // srl x4, x3, x4       ; x4 = x3 >> (x4 & 0x1F)
00020463  // beq x4, x0, 8        ; if x4 == 0 → PC += 8
00000293  // addi x5, x0, 0       ; x5 = 0 + 0 → x5 = 0
0023A233  // sltu x4, x7, x2      ; x4 = (x7 < x2) ? 1 : 0 (sem sinal)
005203B3  // add x7, x4, x5       ; x7 = x4 + x5
402383B3  // sub x7, x7, x2       ; x7 = x7 - x2
0471AA23  // sw x7, 72(x3)        ; MEM[x3 + 72] = x7
06002103  // lw x2, 96(x0)        ; x2 = MEM[96]
005104B3  // xor x9, x2, x5       ; x9 = x2 ^ x5
008001EF  // jal x3, 8            ; x3 = PC+4; PC += 8 (salta 2 instruções)
00100113  // addi x2, x0, 1       ; x2 = 1
00910133  // add x2, x2, x9       ; x2 = x2 + x9
0221A023  // sw x2, 32(x3)        ; MEM[x3 + 32] = x2
00210063  // beq x2, x2, 0        ; sempre verdadeiro → salto 0 (NOP)
